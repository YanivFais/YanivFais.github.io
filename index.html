<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Floating-Point Format Visualizer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Fira+Code&display=swap');
        .mono {
            font-family: 'Fira Code', monospace;
        }
        .input-field {
            @apply w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 bg-white;
        }
        .display-box {
            @apply p-3 bg-gray-100 rounded-md text-center border border-gray-200;
        }
        .bit-group {
            @apply p-2 rounded-md text-white text-sm md:text-base cursor-pointer hover:opacity-90;
        }
        .sign-bit { @apply bg-red-500; }
        .exponent-bit { @apply bg-blue-500; }
        .mantissa-bit { @apply bg-green-500; }
        .input-small {
            @apply w-full p-1 border border-gray-300 rounded-md text-sm mono focus:ring-indigo-500 focus:border-indigo-500;
        }
    </style>
</head>
<body class="bg-gray-50 text-gray-800">

    <div class="container mx-auto p-4 md:p-8 max-w-5xl">
        <header class="text-center mb-8">
            <h1 class="text-4xl font-bold text-gray-800">Floating-Point Visualizer</h1>
            <p class="text-lg text-gray-600 mt-2">Explore how different floating-point formats represent decimal numbers. Edit any field to see the others update.</p>
        </header>

        <main class="bg-white p-6 rounded-lg shadow-lg">
            <!-- CONTROLS SECTION -->
            <div class="grid md:grid-cols-3 gap-6 mb-8 border-b pb-8">
                <div>
                    <label for="decimalInput" class="block text-sm font-medium text-gray-700">Decimal Value</label>
                    <input type="number" id="decimalInput" value="6.5" step="any" class="input-field mt-1">
                </div>
                <div>
                    <label for="formatSelect" class="block text-sm font-medium text-gray-700">Select Format</label>
                    <select id="formatSelect" class="input-field mt-1">
                        <option value="fp32">FP32 (Single Precision)</option>
                        <option value="fp16">FP16 (Half Precision)</option>
                        <option value="bf16">BF16 (BFloat16)</option>
                        <option value="fp8_e5m2">FP8 (E5M2)</option>
                        <option value="fp8_e4m3">FP8 (E4M3)</option>
                        <option value="fp4_e2m1" selected>FP4 (E2M1 - OCP MX)</option>
                    </select>
                </div>
                <div>
                    <label for="biasInput" class="block text-sm font-medium text-gray-700">Exponent Bias</label>
                    <input type="number" id="biasInput" value="1" class="input-field mt-1">
                </div>
            </div>

            <!-- RESULTS DISPLAY -->
            <div class="space-y-6">
                <!-- Binary Breakdown -->
                <div>
                    <h3 class="font-semibold text-lg mb-2">Binary Breakdown (Click to Flip Bit)</h3>
                    <div id="binaryBreakdown" class="flex items-center space-x-1 md:space-x-2 p-3 bg-gray-50 rounded-lg overflow-x-auto">
                        <!-- Content generated by JS -->
                    </div>
                </div>

                <!-- Representations -->
                <div class="grid md:grid-cols-3 gap-4">
                    <div>
                        <h3 class="font-semibold text-lg mb-2">Full Binary</h3>
                        <input id="binaryValue" class="input-field mono text-sm break-all" />
                    </div>
                    <div>
                        <h3 class="font-semibold text-lg mb-2">Hexadecimal</h3>
                        <input id="hexValue" class="input-field mono" />
                    </div>
                    <div>
                        <h3 class="font-semibold text-lg mb-2">Reconstructed Value</h3>
                        <div id="reconstructedValue" class="display-box mono font-bold text-indigo-600">0.0</div>
                    </div>
                </div>
                
                <!-- Decoded Parts -->
                 <div>
                    <h3 class="font-semibold text-lg mb-2">Decoded Components (Editable)</h3>
                    <div class="grid grid-cols-3 gap-x-4 gap-y-2 p-4 border rounded-lg bg-gray-50">
                        <!-- Sign -->
                        <div class="font-medium">Sign</div>
                        <div class="col-span-2">
                            <label class="text-xs text-gray-500">Binary</label>
                            <input id="compSignBin" class="input-small" maxlength="1"/>
                        </div>
                        
                        <!-- Exponent -->
                        <div class="font-medium">Exponent</div>
                        <div>
                            <label class="text-xs text-gray-500">Binary</label>
                            <input id="compExpBin" class="input-small"/>
                        </div>
                        <div>
                            <label class="text-xs text-gray-500">Decimal</label>
                            <input type="number" id="compExpDec" class="input-small"/>
                        </div>

                        <!-- Mantissa -->
                        <div class="font-medium">Mantissa</div>
                         <div>
                            <label class="text-xs text-gray-500">Binary</label>
                            <input id="compMantBin" class="input-small"/>
                        </div>
                        <div>
                            <label class="text-xs text-gray-500">Decimal</label>
                            <input type="number" id="compMantDec" class="input-small"/>
                        </div>
                    </div>
                </div>

                <!-- Special Value Info -->
                <div id="specialValueInfo" class="text-center text-gray-600 p-3 bg-yellow-50 rounded-md border border-yellow-200 hidden">
                    <!-- Content generated by JS -->
                </div>
            </div>
        </main>
        
        <footer class="text-center mt-8 text-sm text-gray-500">
            <p>IEEE 754 and OCP MX Floating point representation tool.</p>
        </footer>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- Element Cache ---
            const elements = {
                decimalInput: document.getElementById('decimalInput'),
                formatSelect: document.getElementById('formatSelect'),
                biasInput: document.getElementById('biasInput'),
                binaryBreakdown: document.getElementById('binaryBreakdown'),
                binaryValue: document.getElementById('binaryValue'),
                hexValue: document.getElementById('hexValue'),
                reconstructedValue: document.getElementById('reconstructedValue'),
                specialValueInfo: document.getElementById('specialValueInfo'),
                compSignBin: document.getElementById('compSignBin'),
                compExpBin: document.getElementById('compExpBin'),
                compExpDec: document.getElementById('compExpDec'),
                compMantBin: document.getElementById('compMantBin'),
                compMantDec: document.getElementById('compMantDec'),
            };

            const FORMATS = {
                'fp32':   { name: 'FP32', totalBits: 32, expBits: 8, mantBits: 23, defaultBias: 127 },
                'fp16':   { name: 'FP16', totalBits: 16, expBits: 5, mantBits: 10, defaultBias: 15 },
                'bf16':   { name: 'BF16', totalBits: 16, expBits: 8, mantBits: 7,  defaultBias: 127 },
                'fp8_e5m2': { name: 'FP8 (E5M2)', totalBits: 8, expBits: 5, mantBits: 2, defaultBias: 15 },
                'fp8_e4m3': { name: 'FP8 (E4M3)', totalBits: 8, expBits: 4, mantBits: 3, defaultBias: 7 },
                'fp4_e2m1': { name: 'FP4 (E2M1)', totalBits: 4, expBits: 2, mantBits: 1, defaultBias: 1 },
            };
            
            let state = {
                bits: 0,
                format: FORMATS.fp4_e2m1,
                bias: 1
            };

            // --- Update Functions from User Input ---
            function updateFromDecimal() {
                const value = parseFloat(elements.decimalInput.value);
                if (isNaN(value)) return;
                const { bits } = floatToCustomFormat(value, state.format, state.bias);
                state.bits = bits;
                renderAll();
            }

            function updateFromBits(newBits) {
                if (isNaN(newBits)) return;
                state.bits = newBits;
                renderAll();
            }
            
            function updateFromHex() {
                const hexString = elements.hexValue.value.startsWith('0x') ? elements.hexValue.value.substring(2) : elements.hexValue.value;
                const newBits = parseInt(hexString, 16);
                updateFromBits(newBits);
            }

            function updateFromBinary() {
                const newBits = parseInt(elements.binaryValue.value, 2);
                updateFromBits(newBits);
            }

            function updateFromComponents() {
                const sign = parseInt(elements.compSignBin.value, 2) || 0;
                const exp = parseInt(elements.compExpBin.value, 2) || 0;
                const mant = parseInt(elements.compMantBin.value, 2) || 0;

                if (isNaN(sign) || isNaN(exp) || isNaN(mant)) return;
                
                const newBits = (sign << (state.format.totalBits - 1)) | (exp << state.format.mantBits) | mant;
                updateFromBits(newBits);
            }

            function onFormatChange() {
                state.format = FORMATS[elements.formatSelect.value];
                state.bias = state.format.defaultBias;
                elements.biasInput.value = state.bias;
                updateFromDecimal(); // Recalculate based on current decimal value for new format
            }

            // --- Core Conversion Logic ---
            function floatToCustomFormat(value, format, bias) {
                const buffer = new ArrayBuffer(4);
                const view = new DataView(buffer);
                view.setFloat32(0, value, false);
                const fp32Bits = view.getUint32(0);

                const sign = (fp32Bits >> 31) & 1;
                let exp = (fp32Bits >> 23) & 0xFF;
                let mant = fp32Bits & 0x7FFFFF;

                const maxExp = (1 << format.expBits) - 1;

                if (exp === 255) return { bits: (sign << (format.totalBits - 1)) | (maxExp << format.mantBits) | (mant ? (1 << (format.mantBits-1)) : 0), special: mant === 0 ? 'Infinity' : 'NaN' };
                if (value === 0) return { bits: sign << (format.totalBits - 1), special: 'Zero' };

                let newExp = exp - 127 + bias;
                if (exp === 0) newExp = 1 - 127 + bias;

                // Rounding logic: add half of the smallest representable bit before truncating
                const rounding_add = 1 << (23 - format.mantBits - 1);
                mant += rounding_add;

                let newMant = mant >> (23 - format.mantBits);

                if (newMant >= (1 << format.mantBits)) {
                    newMant = 0;
                    newExp++;
                }

                if (newExp <= 0) {
                    newMant = (newMant | (1 << format.mantBits)) >> (1 - newExp);
                    newExp = 0;
                }

                if (newExp >= maxExp) return { bits: (sign << (format.totalBits - 1)) | (maxExp << format.mantBits), special: 'Infinity (Overflow)' };
                
                const finalBits = (sign << (format.totalBits - 1)) | (newExp << format.mantBits) | newMant;
                return { bits: finalBits, special: newExp === 0 ? 'Subnormal' : 'Normal' };
            }

            function customBitsToFloat(bits, format, bias) {
                const sign = (bits >> (format.totalBits - 1)) & 1;
                const exp = (bits >> format.mantBits) & ((1 << format.expBits) - 1);
                const mant = bits & ((1 << format.mantBits) - 1);
                const maxExp = (1 << format.expBits) - 1;

                if (exp === maxExp) return mant === 0 ? (sign ? -Infinity : Infinity) : NaN;
                if (exp === 0 && mant === 0) return sign ? -0.0 : 0.0;

                let f_val;
                if (exp === 0) { // Subnormal
                    const mant_val = mant / Math.pow(2, format.mantBits);
                    f_val = mant_val * Math.pow(2, 1 - bias);
                } else { // Normal
                    const mant_val = 1 + (mant / Math.pow(2, format.mantBits));
                    f_val = mant_val * Math.pow(2, exp - bias);
                }
                return sign ? -f_val : f_val;
            }

            // --- Rendering Function (Single Source of Truth) ---
            function renderAll() {
                const { bits, format, bias } = state;
                const { totalBits, expBits, mantBits } = format;

                const signBit = (bits >> (totalBits - 1)) & 1;
                const expVal = (bits >> mantBits) & ((1 << expBits) - 1);
                const mantVal = bits & ((1 << mantBits) - 1);

                // Update decimal input if it's not the source of the change
                const reconstructed = customBitsToFloat(bits, format, bias);
                if (document.activeElement !== elements.decimalInput) {
                    elements.decimalInput.value = reconstructed;
                }
                elements.reconstructedValue.textContent = reconstructed.toPrecision(8);
                
                // Update binary/hex inputs if not the source of change
                if (document.activeElement !== elements.binaryValue) {
                    elements.binaryValue.value = bits.toString(2).padStart(totalBits, '0');
                }
                if (document.activeElement !== elements.hexValue) {
                    elements.hexValue.value = '0x' + bits.toString(16).toUpperCase().padStart(Math.ceil(totalBits / 4), '0');
                }
                
                // Update component inputs if not the source of change
                if (!['compSignBin', 'compExpBin', 'compExpDec', 'compMantBin', 'compMantDec'].includes(document.activeElement.id)) {
                    elements.compSignBin.value = signBit;
                    elements.compExpBin.value = expVal.toString(2).padStart(expBits, '0');
                    elements.compExpDec.value = expVal;
                    elements.compMantBin.value = mantVal.toString(2).padStart(mantBits, '0');
                    elements.compMantDec.value = mantVal;
                }

                // Update visual binary breakdown
                const signStr = `<div class="bit-group sign-bit mono" data-pos="${totalBits - 1}">${signBit}</div>`;
                let expStr = '';
                for (let i = expBits - 1; i >= 0; i--) {
                    expStr += `<div class="bit-group exponent-bit mono" data-pos="${mantBits + i}">${(expVal >> i) & 1}</div>`;
                }
                let mantStr = '';
                for (let i = mantBits - 1; i >= 0; i--) {
                    mantStr += `<div class="bit-group mantissa-bit mono" data-pos="${i}">${(mantVal >> i) & 1}</div>`;
                }
                elements.binaryBreakdown.innerHTML = `${signStr}<div class="w-2"></div>${expStr}<div class="w-2"></div>${mantStr}`;

                // Update special value info
                const maxExp = (1 << expBits) - 1;
                let special = '';
                if (expVal === maxExp) special = (mantVal === 0) ? 'Infinity' : 'NaN';
                else if (expVal === 0 && mantVal === 0) special = 'Zero';
                else if (expVal === 0) special = 'Subnormal';
                else special = 'Normal';

                if (special) {
                    elements.specialValueInfo.textContent = `Value Type: ${special}`;
                    elements.specialValueInfo.classList.remove('hidden');
                } else {
                    elements.specialValueInfo.classList.add('hidden');
                }
            }

            // --- Event Listeners ---
            elements.decimalInput.addEventListener('input', updateFromDecimal);
            elements.formatSelect.addEventListener('change', onFormatChange);
            elements.biasInput.addEventListener('input', () => { state.bias = parseInt(elements.biasInput.value, 10) || 0; updateFromDecimal(); });
            elements.binaryValue.addEventListener('input', updateFromBinary);
            elements.hexValue.addEventListener('input', updateFromHex);
            
            // Component listeners
            elements.compSignBin.addEventListener('input', updateFromComponents);
            elements.compExpBin.addEventListener('input', updateFromComponents);
            elements.compMantBin.addEventListener('input', updateFromComponents);
            elements.compExpDec.addEventListener('input', () => {
                const decVal = parseInt(elements.compExpDec.value, 10) || 0;
                elements.compExpBin.value = decVal.toString(2).padStart(state.format.expBits, '0');
                updateFromComponents();
            });
            elements.compMantDec.addEventListener('input', () => {
                const decVal = parseInt(elements.compMantDec.value, 10) || 0;
                elements.compMantBin.value = decVal.toString(2).padStart(state.format.mantBits, '0');
                updateFromComponents();
            });

            // Click to flip bits
            elements.binaryBreakdown.addEventListener('click', (e) => {
                const target = e.target;
                if (target.hasAttribute('data-pos')) {
                    const pos = parseInt(target.getAttribute('data-pos'), 10);
                    const newBits = state.bits ^ (1 << pos);
                    updateFromBits(newBits);
                }
            });

            // Initial call
            onFormatChange();
        });
    </script>
</body>
</html>
